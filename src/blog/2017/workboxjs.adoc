:doctitle: Workbox la toolbox pour les progressive webapps
:description:  Comment utiliser Workbox la nouvelle toolbox de Google faite pour faciiter la création de vos progressive webapps
:keywords: Web, PWA, ServiceWorker, Workbox
:author: Guillaume EHRET - Dev-Mind
:revdate: 2017-07-02
:category: Web
:teaser: Notre voyage pour mieux connaître les services workers s'achève avec la présentation de la nouvelle toolbox présentée à Google IO/2017, Workbox et Lighthouse
:status: draft

Après avoir présenter ce qu'https://www.dev-mind.fr/blog/2017/service_worker.html[était un service worker] et comment https://www.dev-mind.fr/blog/2017/creer_service_worker.html[en ajouter un dans votre application], nous allons aujourd'hui nous attarder sur la nouvelle toolbox https://workboxjs.org/[Workbox] présentée à Google IO/2017.

== Pourquoi un nouveau projet ?

On peut se poser la question de pourquoi Google met en place un nouveau projet alors que des solutions comme https://github.com/GoogleChrome/sw-precache[sw-precache] et https://github.com/GoogleChrome/sw-toolbox[sw-toolbox] existent (voir https://www.dev-mind.fr/blog/2017/creer_service_worker.html[mon dernier article] sur le sujet). En fait il y a eu pas mal de modifications dans le code depuis la mise en place de ces solutions et https://github.com/GoogleChrome/sw-toolbox[sw-toolbox] n'adresse pour le moment qu'une partie de ce que vous pouvez faire avec des services workers (exclusivement du cache de ressources). Il fallait donc revoir pas mal de choses et comme beaucoup de personnes utilisent déjà ces projets il était difficile de faire de gros changement sans mettre en péril la compatibilité ascendante.

https://workboxjs.org/[Workbox] a été pensé de manière modulaire, et vous pouvez choisir de n'utiliser que les éléments dont vous avez besoin. Quand vous voulez créer des sites performants, il est important de n'embarquer que les ressources vraiment nécéssaires pour limiter un maximum la taille de votre site.


== Qu'est ce que Workbox ?

https://workboxjs.org/[Workbox] a été créé pour vous faciliter la mise en place de nombreuses fonctionnalités construites sur les services workers. Le but est de vous fournir un maximum d'outils pour transformer votre application en https://www.dev-mind.fr/blog/2017/service_worker.html[progressive webapp]. https://workboxjs.org/[Workbox] permet de générer les fichiers de configuration et de vous appuyer sur des scénarios éprouvés.

Utiliser les services workers est assez sensible au niveau sécurité et au niveau de la gestion du cache des ressources. Il est à mon sens important d'utiliser une librairie externe qui évolue sans cesse et où les bug fix sont résolus rapidement.

Comme je le disais plus haut https://workboxjs.org/[Workbox] a vraiment été pensé de manière modulaire. C'est un peu comme un magasin dans lequel vous allez pouvoir faire votre marché, parmi plusieurs librairies ou outils faiblement couplés les uns avec les autres.


=== Outils de générations

Avant de voir en détail les modules bas niveau nous allons regarder comment utiliser ceux de plus haut niveau. Workbox a été créé pour vous faciliter la configuration et peut facilement s'intégrer dans le build de votre application. Il existe différents clients

* Client pour webpack : https://workboxjs.org/get-started/webpack.html[workbox-webpack-plugin]
* Client pour npm : https://workboxjs.org/get-started/npm-script.html[workbox-cli]
* Client pour Gulp : https://workboxjs.org/get-started/gulp.html[workbox-build]

Il est intéressant de noter qu'il n'y a pas de client direct pour le moment pour https://gruntjs.com/[Grunt].

Vous pouvez directement créer votre service worker en vous basant sur https://workboxjs.org/reference-docs/latest/module-workbox-sw.html[workbox-sw] mais il est plutôt fortement recommandé de générer votre service worker avec les clients évoqués ci dessus. La configuration des clients va peu évoluer à l'avenir alors que l'API de workbox-sw va changer.

Nous allons maintenant nous attarder sur les modules bas niveau. Comme je raccroche cet article à mon quotidien, je vais plutôt parler de comment utiliser Workbox avec Gulp. Vous pouvez consulter les https://github.com/Dev-Mind/dev-mind.com[sources] de mon site web pour voir un exemple complet d'utilisation.

=== Le cache de ressources

Si vous utilisiez https://github.com/GoogleChrome/sw-precache[sw-precache]  et https://github.com/GoogleChrome/sw-toolbox[sw-toolbox] nous allons tout d'abord regarder les modules qui reproduisent le comportement de ces librairies.

==== https://workboxjs.org/reference-docs/latest/module-workbox-build.html[workbox-build]
Ce module node s'intègre facilement à votre processus de build Gulp ou Webpack ou autre... et permet de générer votre fichier service worker ou un fichier manifest.

Le but est de générer la liste des ressources qui peuvent être "précachées" par un service worker. Un hash est associé à chacune des ressources afin de pouvoir mettre à jour intelligemment le cache et supprimer les ressources qui ne seraient plus à jour. Cette librairie permet soit de

* générer un service worker avec la liste des ressources à mettre dans le cache
* générer un fichier manifest pour ensuite l'injecter dans votre application pour pouvoir accéder aux URL et au détail des modificatons des ressources
* injecter un fichier manifest dans un service worker existant. Vous controlez l'écriture de votre service worker tout en bénéficiant du précaching automatique

==== https://workboxjs.org/reference-docs/latest/module-workbox-routing.html[workbox-routing]

Le service worker est à l'écoute des requêtes sortantes (fetch event). Nous avons besoin de définir des comportements différents selon les requêtes. Ce module permet d'appliquer différentes stratégies sur des sous ensembles de requêtes. Ceci se fait en définissant des routes

Une route met en relation

 * un matcher : élément permettant de définir un sous ensemble de requêtes.
 * un handler : définissant la stratégie à appliquer à la réponse

Il existe différents types de routes qui vont vous permettre d'utiliser des matchers différents

La communauté JS aime beaucoup ExpressJS et notamment la manière de définir des URL. https://workboxjs.org/reference-docs/latest/module-workbox-routing.ExpressRoute.html#main[ExpressRoute]. Cette route permet de les utiliser. Une autre manière de définir des routes est d'utiliser des expressions régulières. Pour celà vous pouvez utiliser la route https://workboxjs.org/reference-docs/latest/module-workbox-routing.RegExpRoute.html[RegExpRoute].

[source, javascript, subs="none"]
----
 const assetRoute = new RegExpRoute({
   regExp: /assets/,
   handler: new workbox.runtimeCaching.StaleWhileRevalidate(),
 });
 const imageRoute = new RegExpRoute({
   regExp: /images/,
   handler: new workbox.runtimeCaching.CacheFirst(),
 });
 const route = new workbox.routing.ExpressRoute({
  path: 'https://example.com/path/to/:file'
 });

 const router = new workbox.routing.Router();
 router.registerRoutes({routes: [assetRoute, imageRoute]});
 router.setDefaultHandler({
   handler: new workbox.runtimeCaching.NetworkFirst(),
 });
----

Dans l'exemple ci dessus vous pourriez implémenter vos propres handlers mais il est préférable d'utiliser les handlers mis à dispositions. Nous allons d'ailleurs regarder dès maintenant le module les mettant à disposition.

==== https://workboxjs.org/reference-docs/latest/module-workbox-runtime-caching.html[workbox-runtime-caching]

Cette librairie implémete les différentes stratégies de cache. Comme je vous l'avais indiqué dans l'article précédent vous pouvez lire le https://jakearchibald.com/2014/offline-cookbook/[offline cookbook] de https://twitter.com/jaffathecake[Jake Archibald] qui décrit ces différentes stratégies.

* _networkFirst_ : essaye de lancer la requête en mode connecté. Si le réseau répond la réponse est stockée dans le cache et servie. Si la réponse dépasse un timeout défini ou si le réseau est inaccessible le SW retourne la ressource si elle est présente dans le cache. Cette stratégie est intéressante quand vous voulez afficher les données les plus récentes.
* _cacheFirst_ : si la ressource est dans le cache elle est directment renvoyée. Sinon on charge la ressource. Cette stratégie est utilisée pour des éléments qui ne changent pas (sinon vous devez mettre en place une stratégie pour mettre à jour ces ressources quand elles changent).
* _cacheOnly_ : on ne regarde que dans le cache. Si la ressource n'est pas là nous avons une erreur. Intéressant sur mobile par exemple pour préserver la batterie quand elle commence à faiblir.
* _networkOnly_ : inverse on interroge toujours le réseau. Cette stratégie est un peu inutile vu qu'il se passe la même chose si vous n'utilisez pas de services workers
* _networkOnly_ : inverse on interroge toujours le réseau. Cette stratégie est un peu inutile vu qu'il se passe la même chose si vous n'utilisez pas de services workers
* _staleWhileRevalidate_ : on lance 2 requêtes en parallèle (une dans le cache un sur le réseau). La version en cache étant plus rapide à répondre est affichée mais cette version sera remplacée par lé résultat de la reuête lancée sur le réseau si cette dernière s'est bien passée.

Vous pouvez voir des exemples dans le paragraphe précédent

==== https://workboxjs.org/reference-docs/latest/module-workbox-cache-expiration.html#workbox-cache-expiration[workbox-cache-expiration]

Quand vous utilisez des services workers ou plus généralement du cache de ressources dans le navigateur web vous avez toujours la hantise que votre cache soit mal configuré et que les ressources ne soient jamais mise à jour.

Grâce à cette librairie vous pouvez

* limiter la taille du cache en limitant le nombre de requêtes pouvant être "cachée"
* définir une date d'expiration

[source, javascript, subs="none"]
----
const requestWrapper = new workbox.runtimeCaching.RequestWrapper({
  cacheName: 'runtime-cache',
  plugins: [
    // The cache size will be capped at 10 entries.
    new workbox.cacheExpiration.Plugin({maxEntries: 10, maxAgeSeconds: 10})
  ]
});

// ce `RequestWrapper` peut être ajouté au cache handler d'une route
const route = new workbox.routing.RegExpRoute({
  match: ({url}) => url.domain === 'dev-mind.fr',
  handler: new workbox.runtimeCaching.StaleWhileRevalidate({requestWrapper})
});
----

=== Aller plus loin

https://workboxjs.org/[Workbox] a l'ambition d'apporter plus que du cache de ressources.

==== https://workboxjs.org/reference-docs/latest/module-workbox-background-sync.html[workbox-background-sync]

Les services workers vous permettent de servir votre site web si le réseau est défaillant ou absent. Si un utilisateur lance une action et que le réseau n'est pas accessible cette dernière est perdue. Cette librairie va vous aider à empiler les demandes dans une queue et ces demandes seront exécutées quand le réseau sera à nouveau disponible (cette librairie se base sur l'API JavaScript Background Sync).

Le principe est d'instancier une https://workboxjs.org/reference-docs/latest/module-workbox-background-sync.QueuePlugin.html[QueuePlugin] et de la passer au RequestWrapper

[source, javascript, subs="none"]
----
let bgQueue = new workbox.backgroundSync.QueuePlugin({
  callbacks: {
    onResponse: async(hash, res) => {
      self.registration.showNotification('Background sync demo', {
        body: 'Product has been purchased.',
        icon: '/images/shop-icon-384.png',
       });
    },
    onRetryFailure: (hash) => {},
  },
});

const requestWrapper = new workbox.runtimeCaching.RequestWrapper({
  plugins: [bgQueue],
});

const route = new workbox.routing.RegExpRoute({
  regExp: new RegExp('^https://jsonplaceholder.typicode.com'),
  handler: new workbox.runtimeCaching.NetworkOnly({requestWrapper}),
});

const router = new workbox.routing.Router();
router.registerRoute({route});
----

==== https://workboxjs.org/reference-docs/latest/module-workbox-cacheable-response.html[workbox-cacheable-response]

Cette librairie vous permet de paramétrer finement quels objets doivent être mis en cache ou non. Pour celà vous pouvez intercepter le statut de la réponse ou les entêtes de cette réponse.

Un petit exemple dans lequel nous ne voulons mettre en cache que les réponses avec le statut 0 ou 200

[source, javascript, subs="none"]
----
const cacheablePlugin = new workbox.cacheableResponse.Plugin({
  statuses: [0, 200]
});

const requestWrapper = new workbox.runtimeCaching.RequestWrapper({
  cacheName: 'runtime-cache',
  plugins: [
    cacheablePlugin
  ]
});

const route = new workbox.routing.RegExpRoute({
  match: ({url}) => url.domain === 'example.com',
  handler: new workbox.runtimeCaching.StaleWhileRevalidate({requestWrapper})
});
----

==== https://workboxjs.org/reference-docs/latest/module-workbox-broadcast-cache-update.html[workbox-broadcast-cache-update]

Cet utilitaire utilise l'API JavaScript Broadcast Channel et permet d'effectuer une action quand une entrée dans le cache a été mise à jour.

[source, javascript, subs="none"]
----
const requestWrapper = new workbox.runtimeCaching.RequestWrapper({
  cacheName: 'text-files',
  plugins: [
    new workbox.broadcastCacheUpdate.BroadcastCacheUpdatePlugin(
      {channelName: 'cache-updates'})
  ],
});

const route = new workbox.routing.RegExpRoute({
  regExp: /\.txt$/,
  handler: new workbox.runtimeCaching.StaleWhileRevalidate({requestWrapper}),
});

const router = new workbox.routing.Router();
router.registerRoute({route});
----

Ensuite dans votre code vous pouvez écouter l'événement du même nom

[source, javascript, subs="none"]
----
const updateChannel = new BroadcastChannel('cache-updates');
updateChannel.addEventListener('message', event => {
  console.log(`Cache updated: ${event.data.payload.updatedUrl}`);
});
----

== Vérifier le fonctionnement de votre site

Une fois que vous avez mis en ligne votre site, vous pouvez utiliser

C'est ce que nous verrons dans le prochain article sur les services workers



Most developers will use this module by instantiating a new BroadcastCacheUpdatePlugin and passing it to a RequestWrapper, as shown in the first example below.

You can listen for updates from your web app by adding an event listener on a BroadcastChannel within a page, using the same channel name as what's used within the service worker, as shown in the second example.





You're sold on the advantages of adding a service worker to your web app—swapping the uncertainty of the network for the promise of a fast, offline- first, service worker-powered experience. But to write your own service worker from scratch, you have to clear some hurdles:

Precaching URLs easily and reliably.
Incrementing a cache version string to ensure that precached resources are updated.
Implementing a cache expiration strategy to account for cache size or entry age.
Building common patterns such as lie-fi network timeouts and boilerplate code.
Capturing and reporting Google analytics data during offline usage.
You can address all of these drawbacks using Workbox.


